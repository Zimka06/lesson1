package org.example;
import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

// ================= MAIN =================
public class CalculatorMain {
    public static void main(String[] args) {
        SwingUtilities.invokeLater(CalculatorController::new);
    }
}

// ================= MODEL =================
interface CalculatorObserver {
    void updateDisplay();
}

class CalculatorModel {
    private double currentValue;
    private double memoryValue;
    private List<String> calculationHistory;
    private List<CalculatorObserver> observers;

    public CalculatorModel() {
        currentValue = 0.0;
        memoryValue = 0.0;
        calculationHistory = new ArrayList<>();
        observers = new ArrayList<>();
    }

    public void addObserver(CalculatorObserver observer) {
        observers.add(observer);
    }

    public void notifyObservers() {
        for (CalculatorObserver observer : observers) {
            observer.updateDisplay();
        }
    }

    public void setCurrentValue(double value) {
        this.currentValue = value;
    }

    public double getCurrentValue() {
        return currentValue;
    }

    public void addHistory(String entry) {
        calculationHistory.add(entry);
    }

    public List<String> getCalculationHistory() {
        return new ArrayList<>(calculationHistory);
    }

    public void clear() {
        currentValue = 0.0;
        notifyObservers();
    }

    public void memoryStore() {
        memoryValue = currentValue;
    }

    public void memoryRecall() {
        currentValue = memoryValue;
        notifyObservers();
    }
}

// ================= OPERATIONS =================
interface OperationBehavior {
    double execute(double a, double b);
    String getSymbol();
}

class AddOperation implements OperationBehavior {
    @Override public double execute(double a, double b) { return a + b; }
    @Override public String getSymbol() { return "+"; }
}

class SubtractOperation implements OperationBehavior {
    @Override public double execute(double a, double b) { return a - b; }
    @Override public String getSymbol() { return "-"; }
}

class MultiplyOperation implements OperationBehavior {
    @Override public double execute(double a, double b) { return a * b; }
    @Override public String getSymbol() { return "×"; }
}

class DivideOperation implements OperationBehavior {
    @Override
    public double execute(double a, double b) {
        if (b == 0) throw new ArithmeticException("Division by zero");
        return a / b;
    }
    @Override public String getSymbol() { return "÷"; }
}

// ================= COMMANDS =================
interface Command {
    void execute();
}

class SaveCalculationCommand implements Command {
    private final CalculatorState state;
    private final JFrame parentFrame;

    public SaveCalculationCommand(CalculatorState state, JFrame parentFrame) {
        this.state = state;
        this.parentFrame = parentFrame;
    }

    @Override
    public void execute() {
        JFileChooser fileChooser = new JFileChooser();
        fileChooser.setDialogTitle("Сохранить историю расчётов");
        fileChooser.setSelectedFile(new java.io.File("calculations.txt"));

        int result = fileChooser.showSaveDialog(parentFrame);
        if (result == JFileChooser.APPROVE_OPTION) {
            try {
                String filePath = fileChooser.getSelectedFile().getAbsolutePath();
                saveCalculations(filePath);
                JOptionPane.showMessageDialog(parentFrame,
                        "История сохранена:\n" + filePath,
                        "Успешно", JOptionPane.INFORMATION_MESSAGE);
            } catch (IOException e) {
                JOptionPane.showMessageDialog(parentFrame,
                        "Ошибка сохранения:\n" + e.getMessage(),
                        "Ошибка", JOptionPane.ERROR_MESSAGE);
            }
        }
    }

    private void saveCalculations(String filePath) throws IOException {
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(filePath))) {
            writer.write("=== История расчётов ===\n");
            List<String> history = state.getModel().getCalculationHistory();
            if (history.isEmpty()) {
                writer.write("Нет записей.\n");
            } else {
                for (String entry : history) {
                    writer.write(entry);
                    writer.write('\n');
                }
            }
        }
    }
}

// ================= CONTROLLER & STATE =================
class CalculatorController {
    private final CalculatorModel model;
    private final CalculatorState state;
    private final CalculatorFrame frame;
    private final CalculatorPanel panel;

    public CalculatorController() {
        model = new CalculatorModel();
        state = new CalculatorState(model);
        panel = new CalculatorPanel(this);
        model.addObserver(panel);
        frame = new CalculatorFrame(state, this);
        frame.setDisplayPanel(panel);
        frame.setVisible(true);
    }

    public void handleNumberInput(String digit) { state.handleNumberInput(digit); }
    public void handleOperation(OperationBehavior operation) { state.setCurrentOperation(operation); }
    public void performCalculation() { state.performCalculation(); }
    public void clearCalculator() { state.clear(); }
    public CalculatorModel getModel() { return model; }
}

class CalculatorState {
    private final CalculatorModel model;
    private OperationBehavior currentOperation;
    private double firstOperand;
    private StringBuilder currentInput;
    private boolean newInput;

    public CalculatorState(CalculatorModel model) {
        this.model = model;
        this.currentOperation = new AddOperation();
        this.firstOperand = 0.0;
        this.currentInput = new StringBuilder("0");
        this.newInput = true;
    }

    public void handleNumberInput(String digit) {
        if (newInput) {
            currentInput.setLength(0);
            newInput = false;
        }
        if (".".equals(digit) && currentInput.indexOf(".") != -1) return;
        if (currentInput.length() == 0 && ".".equals(digit)) currentInput.append("0");
        currentInput.append(digit);

        try {
            double value = Double.parseDouble(currentInput.toString());
            model.setCurrentValue(value);
            model.notifyObservers();
        } catch (NumberFormatException ignored) {}
    }

    public void setCurrentOperation(OperationBehavior operation) {
        if (!newInput) performPendingOperation();
        firstOperand = model.getCurrentValue();
        currentOperation = operation;
        newInput = true;
    }

    public void performCalculation() {
        if (!newInput) {
            performPendingOperation();
            newInput = true;
        }
    }

    public void clear() {
        currentInput.setLength(0);
        currentInput.append("0");
        model.setCurrentValue(0.0);
        firstOperand = 0.0;
        currentOperation = new AddOperation();
        newInput = true;
        model.notifyObservers();
    }

    private void performPendingOperation() {
        double secondOperand = model.getCurrentValue();
        double result;
        try {
            result = currentOperation.execute(firstOperand, secondOperand);
        } catch (ArithmeticException e) {
            result = Double.NaN;
        }

        model.setCurrentValue(result);
        String entry = String.format("%.2f %s %.2f = %.2f",
                firstOperand, currentOperation.getSymbol(), secondOperand, result);
        model.addHistory(entry);
        model.notifyObservers();
    }

    public CalculatorModel getModel() { return model; }
}

// ================= VIEW =================
class CalculatorFrame extends JFrame {
    public CalculatorFrame(CalculatorState state, CalculatorController controller) {
        setTitle("Калькулятор — Programming Technologies");
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setSize(360, 480);
        setResizable(false);
        setLocationRelativeTo(null);
        setupMenu(state);
    }

    public void setDisplayPanel(JPanel panel) {
        setContentPane(panel);
    }

    private void setupMenu(CalculatorState state) {
        JMenuBar menuBar = new JMenuBar();
        JMenu fileMenu = new JMenu("Файл");

        JMenuItem saveItem = new JMenuItem("Сохранить историю...");
        saveItem.addActionListener(e -> {
            SaveCalculationCommand cmd = new SaveCalculationCommand(state, this);
            cmd.execute();
        });

        JMenuItem exitItem = new JMenuItem("Выход");
        exitItem.addActionListener(e -> System.exit(0));

        fileMenu.add(saveItem);
        fileMenu.addSeparator();
        fileMenu.add(exitItem);
        menuBar.add(fileMenu);
        setJMenuBar(menuBar);
    }
}

class CalculatorPanel extends JPanel implements CalculatorObserver {
    private final CalculatorController controller;
    private final JLabel displayLabel;

    public CalculatorPanel(CalculatorController controller) {
        this.controller = controller;
        this.displayLabel = new JLabel("0.00", SwingConstants.RIGHT);
        setupUI();
    }

    private void setupUI() {
        setLayout(new BorderLayout(5, 5));
        setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));

        displayLabel.setFont(new Font("Monospaced", Font.BOLD, 28));
        displayLabel.setOpaque(true);
        displayLabel.setBackground(Color.WHITE);
        displayLabel.setBorder(BorderFactory.createLoweredBevelBorder());
        add(displayLabel, BorderLayout.NORTH);

        JPanel buttonPanel = new JPanel(new GridLayout(5, 4, 4, 4));
        String[] buttons = {
                "C", "MR", "M+", "÷",
                "7", "8", "9", "×",
                "4", "5", "6", "-",
                "1", "2", "3", "+",
                "0", ".", "±", "="
        };

        for (String text : buttons) {
            JButton btn = new JButton(text);
            btn.setFont(new Font("Arial", Font.BOLD, 16));
            btn.setFocusable(false);

            if ("0123456789.".contains(text)) {
                btn.addActionListener(e -> controller.handleNumberInput(text));
            } else {
                btn.addActionListener(this::onOperatorClick);
            }

            if ("C".equals(text)) btn.setBackground(new Color(255, 200, 200));
            else if ("=".equals(text)) btn.setBackground(new Color(100, 200, 100));
            else if ("+-×÷".contains(text) || "MR M+".contains(text)) btn.setBackground(new Color(220, 220, 255));

            buttonPanel.add(btn);
        }
        add(buttonPanel, BorderLayout.CENTER);
    }

    private void onOperatorClick(ActionEvent e) {
        String cmd = e.getActionCommand();
        switch (cmd) {
            case "C" -> controller.clearCalculator();
            case "+" -> controller.handleOperation(new AddOperation());
            case "-" -> controller.handleOperation(new SubtractOperation());
            case "×" -> controller.handleOperation(new MultiplyOperation());
            case "÷" -> controller.handleOperation(new DivideOperation());
            case "=" -> controller.performCalculation();
            case "M+" -> controller.getModel().memoryStore();
            case "MR" -> controller.getModel().memoryRecall();
            case "±" -> {
                double v = controller.getModel().getCurrentValue();
                controller.getModel().setCurrentValue(-v);
                controller.getModel().notifyObservers();
            }
        }
    }

    @Override
    public void updateDisplay() {
        double value = controller.getModel().getCurrentValue();
        if (Double.isNaN(value)) {
            displayLabel.setText("Error");
        } else {
            displayLabel.setText(String.format("%.2f", value).replace(",", "."));
        }
    }
}
